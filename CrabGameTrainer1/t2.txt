#include <Mod>
#include <iostream>
#include <Windows.h>
#include <tlhelp32.h>
#include <Psapi.h>
#include <stdio.h>

#include <MinHook.h>

#if _WIN64
#pragma comment(lib, "libMinHook.x64.lib")
#else
#pragma comment(lib, "libMinHook.x86.lib")
#endif

uintptr_t moduleAssemblyBase = 0;

/*
* "Address": 8787552,
      "Name": "System.String$$CreateString",
      "Signature": "System_String_o* System_String__CreateString (System_String_o* __this, System_Char_array* val, const MethodInfo* method);"
*/

typedef struct _monoString
{
	void* klass;
	void* monitor;
	int length;
	char chars[256];
	int getLength()
	{
		return length;
	}
	char* getChars()
	{
		return chars;
	}
	std::string toCPPString()
	{
		char* p = getChars();

		char fullStr[128];

		for (int i = 0; i < getLength(); i++) {

			int index = i * 2;
			char b = *(p + index);

			fullStr[i] = b;


		}

		fullStr[getLength()] = 0;

		return std::string(fullStr);
	}
} monoString;

monoString* CreateMonoString(const char* str) {
	//monoString* (*String_CreateString)(void* instance, const char* str) = (monoString * (*)(void*, const char*))(moduleAssemblyBase + 8787552);
	monoString* (*String_CreateString)(void* _this, const char* str) = (monoString * (*)(void*, const char*))(moduleAssemblyBase + 8787312);
	return String_CreateString(NULL, str);
}

typedef void(__stdcall* tReceiveChatMessage)(long long toClient, monoString* string);
tReceiveChatMessage oReceiveChatMessageTarget; //before
tReceiveChatMessage oReceiveChatMessage = nullptr; //afater

typedef void(__stdcall* tChatBoxUpdate)(void* _this);
tChatBoxUpdate oChatBoxUpdateTarget; //before
tChatBoxUpdate oChatBoxUpdate = nullptr; //afater

typedef void(__stdcall* tForceGiveItem)(long long toClient, int itemId, int objectId);
tForceGiveItem oForceGiveItemTarget; //before

int uniqueItemId = 100;

void __stdcall hReceiveChatMessage(long long toClient, monoString* string)
{
	
	//newStr->length = 1;
	//newStr->chars[0] = 65;

	
	/*
	char szTest[256];
	sprintf_s(szTest, "ServerSend\nhReceiveChatMessage\n fromClient= %lld\n string=%p\n(%s)(%d)", toClient, string, string->toCPPString().c_str(), string->getLength());
	MessageBoxA(NULL, szTest, NULL, NULL);
	*/

	std::string str = string->toCPPString();

	char buffer[256];
	sprintf_s(buffer, "Process: (%s)", str.c_str());

	char* p = buffer;

	//monoString* str2 = CreateMonoString(p);
	//oReceiveChatMessage(1, str2);

	bool sendMessage = true;

	if (str.rfind("!", 0) == 0) {
		if (str.rfind("!glock", 0) == 0) {
			oForceGiveItemTarget(toClient, 1, uniqueItemId++);

			//oReceiveChatMessage(0, CreateMonoString("* glock"));
		}
		
		sendMessage = false;
	}
	

	if (sendMessage) {
		oReceiveChatMessage(toClient, string);
	}
	return;
}

void __stdcall hChatBoxUpdate(void* _this)
{
	//oReceiveChatMessage(1, CreateMonoString("update"));

	return oChatBoxUpdate(_this);
}


DWORD WINAPI MainThread(LPVOID param) {
	//MessageBox(NULL, L"INJECTED", L"INJECTED", NULL);
	

	if (MH_Initialize() != MH_OK) {
		MessageBox(NULL, L"NOT INIT", L"HOOKED", NULL);
		return 0;
	}

	

	moduleAssemblyBase = (uintptr_t)GetModuleHandleW(L"GameAssembly.dll");

	oReceiveChatMessageTarget = (tReceiveChatMessage)(moduleAssemblyBase + 17192320);
	oChatBoxUpdateTarget = (tChatBoxUpdate)(moduleAssemblyBase + 0x1131A00);
	oForceGiveItemTarget = (tForceGiveItem)(moduleAssemblyBase + 12938880);
	
	if (MH_CreateHook(reinterpret_cast<void**>(oReceiveChatMessageTarget), &hReceiveChatMessage, reinterpret_cast<void**>(&oReceiveChatMessage)) == MH_OK) {
		MH_EnableHook(oReceiveChatMessageTarget);
	}
	else {
		MessageBox(NULL, L"NOT HOOKED", L"NOT HOOKED", NULL);

		
	}

	if (MH_CreateHook(reinterpret_cast<void**>(oChatBoxUpdateTarget), &hChatBoxUpdate, reinterpret_cast<void**>(&oChatBoxUpdate)) == MH_OK) {
		MH_EnableHook(oChatBoxUpdateTarget);
	}
	else {
		MessageBox(NULL, L"NOT HOOKED", L"NOT HOOKED", NULL);


	}
	


	

	bool running = true;
	while (running)
	{
		if (GetAsyncKeyState(VK_NUMPAD1)) {
			Sleep(1000);
		}

		if (GetAsyncKeyState(VK_NUMPAD2)) {
			Sleep(200);

		}
		if (GetAsyncKeyState(VK_NUMPAD0)) {
			running = false;
			MessageBox(NULL, L"VK_NUMPAD0", L"VK_NUMPAD0", NULL);
			Sleep(200);

		}
		Sleep(10);
	}
	FreeLibraryAndExitThread((HMODULE)param, 0);
	return 1;
}

BOOL APIENTRY DllMain(HMODULE hModule,
	DWORD  ul_reason_for_call,
	LPVOID lpReserved
)
{
	switch (ul_reason_for_call)
	{
	case DLL_PROCESS_ATTACH:
		CreateThread(NULL, NULL, MainThread, hModule, NULL, NULL);
		break;
	case DLL_THREAD_ATTACH:
	case DLL_THREAD_DETACH:
	case DLL_PROCESS_DETACH:
		break;
	}
	return TRUE;
}